import numpy as np
import torch
import matplotlib.pyplot as plt
from PIL import Image
from torchvision import transforms
import torch.nn.functional as F
from mnist.mnist_net_F import Net
from mnist.utils import img_conv2d, template
import argparse
import os
import time

parser = argparse.ArgumentParser(description="batch classify images")
parser.add_argument('--imagedir', type=str, default='attacks/') # do not change
parser.add_argument('--attack', type=str, default='iFGSM')
args = parser.parse_args()

attack  = args.attack

pathdirs= []
pathdirs.append(args.imagedir + attack + '_ms/original_data')
pathdirs.append(args.imagedir + attack + '_ms/hacked_data')


print("\nStep4: Conducting multiscale detection on adversarial image generated by {} and draw an ROC curve.\n".format(attack))


# load model
net = Net()
params = torch.load('ckpt/model_augemented.pkl')
net.load_state_dict(params)
if torch.cuda.is_available():
    net.cuda()
net.eval()

trans = transforms.Compose([transforms.ToTensor()])

Acc = []

print("Processing: ")
for pathdir in pathdirs:
    Count = 0 
    t_num = 100
    det_acc = np.zeros(t_num+1)
    for name in os.listdir(pathdir):
        filename = os.path.join(pathdir, name)
        true_label = int(filename[-7])
        img = np.load(filename)
        Count += 1
        C = np.zeros((20, 10))

        for i in range(10):
            #  do gaussian blur
            temp = template(2, i * 0.04)
            input_image = img_conv2d(img, temp)
            input_image = np.expand_dims(input_image, 2)
            input_image = trans(input_image / 255)
            input_image = input_image.view(-1, input_image.shape[0], input_image.shape[1], input_image.shape[2])
            input_image = input_image.float()
            preds = F.softmax(net(input_image.cuda()), dim=1)
            C[i, :] = preds.cpu().detach().numpy()

        c = np.zeros(10)

        for i in range(10):
            c[i] = max(C[:, i]) - min(C[:, i])

        fluc = max(c)

        for t in range(t_num+1):
            if fluc > t / t_num:
                det_acc[t] += 1

        if Count >= 500:
            Acc.append(det_acc)
            break


fig, ax = plt.subplots()
TP = Acc[0] / 500
FP = Acc[1] / 500
ax.plot(FP, TP, '-', label=attack)


font = {'family': 'Times New Roman',
        'size': 20,
        }

ax.set_ylabel('True positive rate', fontdict=font)
ax.set_xlabel('False positive rate', fontdict=font)
plt.ylim(-0.01, 1.02)
plt.xlim(-0.01, 1.02)
plt.xticks(fontname='Times New Roman', fontsize=20)
plt.xticks([0, 0.5, 1])
plt.yticks(fontname='Times New Roman', fontsize=20)
plt.yticks([0, 0.5, 1])
plt.legend(ncol=1, loc='lower right', prop=font)
plt.tight_layout(pad=1)
plt.show()

import xlwt
book = xlwt.Workbook(encoding='utf-8', style_compression=0)
sheet = book.add_sheet('sheet1', cell_overwrite_ok=True)

sheet.write(0,0, 'FP')
sheet.write(0,1, 'TP')
sheet.write(0,2, 't')

for i in range(len(FP)):
    sheet.write(i+1, 0, FP[i])
    sheet.write(i+1, 1, TP[i])
    sheet.write(i+1, 2, i/t_num)


book.save('FP_TP_{}.xls'.format(attack))

print("Done! The false positive and true positive values are saved in FP_TP_{}.xls for drawing a roc curve".format(attack) )